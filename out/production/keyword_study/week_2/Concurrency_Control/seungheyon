동시성 제어란, 동일한 데이터에 두 개 이상의 트랜잭션이 동시에 일어날 때 데이터의 정합성을 위해 트랜잭션의 작업 순서를 조정하는 것을 말한다. 
같은 데이터에 일어나는 트랜잭션에 대해 적절한 제어를 하지 않으면, Dirty Read, Non-Repeatable Read, Phantom Read 등 여러 문제가 발생한다. 
일반적으로 읽기 작업은 여러 트랜잭션이 동시에 발생해도 별다른 문제를 야기하지 않지만, 어느 하나 이상의 트랜잭션에서 쓰기 작업을 동반할 때 
다른 트랜잭션의 읽기와 쓰기에 여러 문제가 발생하기 때문에 동시성 제어가 필요하다. 동시성 제어는 데이터 락(data Lock) 을 통해 진행되는데, 
데이터 락에는 읽기를 할 때 사용하는 공유 락(Share Lock), 읽기 또는 쓰기를 할 때 사용하는 베타 락(Exclusive Lock) 이 있다. 이 락을 사용한 
Locking 기법으로 트랜잭션의 동시접근을 제어하는데, 동시성 제어가 정확히 어떤 방법으로 진행되며 누가 주체가 되어 진행하는지 알아보도록 하자.



Lock 을 사용하는 규칙

1. 트랜잭션이 읽기 작업을 할 경우, 데이터에 공유 락(LS)을 요청한다.
2. 트랜잭션이 읽기 또는 쓰기 작업을 할 경우, 데이터에 베타 락(LX) 을 요청한다.
3. 공유 락(LS) 이 걸려있는 데이터에 대해, 다른 트랜잭션이 공유 락(LS) 을 걸 수 있으나 베타 락(LX) 은 걸 수 없다.
4. 베타 락(LX) 이 걸려있는 데이터에 대해, 다른 트랜잭션이 어떤 락도 걸 수 없다.
5. 락을 허용받지 못한 트랜잭션은 대기상태가 된다.



데이터베이스는 로킹을 사용함에 있어서 데이터 정합성 문제를 해결하기 위해 Two-Phase-Locking (2단계 로킹)기법을 사용한다. 2단계 로킹이란 
트랜잭션이 lock 요청만 수행하는 Growing Phase, 트랜잭션이 unlock 요청만 수행하는 Shrinking Phase 의 두 단계로 락을 걸고 해제하는 시점을 
나눠서 관리하는 방법이다. 2단계 로킹 기법은 트랜잭션의 동시성을 어느 정도 보장하도록 도움을 주지만, 데드락(교착상태) 에 빠질 위험이 있어 이를 
관리해야 한다.



트랜잭션 격리 수준

DBMS 는 동시에 발생하는 트랜잭션에 대해서 락을 보다 잘 사용하기 위해 4가지 수준의 격리 수준(트랜잭션이 서로 격리되어있는 수준)을 제공한다. 각 
단계는 데이터에 공유 락과 베타 락을 적절하게 걸어주면서 동시성을 제어한다. 4 단계의 격리 수준은 다음과 같다.

1) READ uncommitted - Level 0
 데이터 정합성과 트랜잭션 일관성에 대해 아무 조치도 취하지 않은 상태로, 변경 내용의 commit 이나 rollback 여부에 상관 없이 값을 읽어올 수 있다. 

2) READ committed - Level 1
 트랜잭션이 완료되고 commit 된 데이터만 다른 트랜잭션에서 접근할 수 있도록 허용된 격리 수준이다. 일반적으로 DBMS 에서 기본적으로 설정된 격리 
수준이다.

3) REPEATABLE READ - Level 2
자신보다 앞서 시작된 트랜잭션에 대해서는 commit된 데이터만 읽을 수 있으며, 자신보다 나중에 시작된 트랜잭션에 대해서는 Undo 영역에 백업된 데이터를 
읽도록 허용된 격리 수준이다. Non Repeatable Read 문제가 발생하지 않지만, 백업 레코드가 많아질수록 성능이 떨어지는 단점이 있다.

4) SERIALIZABLE - Level 3
트랜잭션의 고립성을 철저하게 준수하는, 가장 엄격한 형태의 격리 수준으로 모든 트랜잭션이 직렬되게 동작한다. 일관성 문제가 전혀 발생하지 않지만 
동시성이 떨어지므로 잘 사용되지 않는 격리 수준이다.



각 격리 수준에 맞게 베타 락과 공유 락을 걸어주지만, 아직 베타 락과 공유 락의 매커니즘에 정확히 숙지하지 못하고 있는 것 같다. 예를 들어, READ 
UNCOMMITED 단계는 쓰기 작업 시 베타 락을 걸어주지만 동시에 다른 트랜잭션이 읽기 작업을 하는 것이 가능하다. Why? 베타 락은 공유 락을 허용하지 않을텐데?
